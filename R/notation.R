#' Row and column notation
#' 
#' @description
#' It is often convenient to represent row and column names 
#' with notation that includes a prefix and a suffix,
#' with corresponding separators or start-end string sequences.
#' These functions assist with manipulating row and column names of this type.
#' 
#'  
#' notation symbols in a standard format 
#' that is used by `matsbyname` in several places. 
#' 
#' There are several functions that call `row_col_notation_list()` to generate specialized versions.
#' 
#' * `row_col_notation_list()` builds lists of notation symbols in a standard format 
#'                             that is used by `matsbyname` in several places.
#'                             By default, it builds a list of notation symbols that provides an arrow 
#'                             separator (" -> ") between prefix and suffix.
#' * `arrow_notation()` builds a list of notation symbols that provides an arrow separator (" -> ")
#'                      between prefix and suffix.
#' * `paren_notation()` builds a list of notation symbols that provides square brackets (" [suffix]") around the suffix.
#' * `split_pref_suff()` splits prefixes from suffixes, returning each in a list with names `pref` and `suff`. 
#'                       If no delimiters are found, `x` is returned in the `pref` item, unmodified.
#' * `join_pref_suff()` joins prefixes and suffixes, the inverse of `split_pref_suff()`.
#' * `switch_pref_suff()` switches the location of prefix and suffix, such that the prefix becomes the suffix, and
#'                        the suffix becomes the prefix.
#'                        E.g., "a -> b" becomes "b -> a" or "a \[b\]" becomes "b \[a\]".
#' # `switch_row_col_notation()` switches from one type of notation to another based on the `from` and `to` arguments.
#' 
#' If `sep` only is specified (default is " -> "), 
#' `pref_start`, `pref_end`, `suff_start`, and `suff_end` are 
#' set appropriately.
#' 
#' None of the strings in a notation list are considered part of the prefix or suffix.
#' E.g., "a -> b" in arrow notation means that "a" is the prefix and "b" is the suffix.
#'
#' @param sep a string separator between prefix and suffix. Default is " -> ".
#' @param pref_start a string indicating the start of a prefix. Default is `NULL`.
#' @param pref_end a string indicating the end of a prefix. Default is the value of `sep`.
#' @param suff_start a string indicating the start of a suffix. Default is the value of `sep`.
#' @param suff_end a string indicating the end of a suffix. Default is `NULL`.
#' @param x a string or list of strings to be operated upon
#' @param ps a list of prefixes and suffixes in which each item of the list is itself a list with two items, `pref` and `suff`
#' @param notation_list a notation list generated by one of the `*_notation_list()` functions, such as
#'                      `row_col_notation_list()`, `arrow_notation_list()`, or `paren_notation_list()`. 
#'                      Default is `arrow_notation_list()`.
#' @param from the `notation_list` to switch _away from_
#' @param to the `notation_list` to switch _to_
#'
#' @return a string list with named items `pref_start`, `pref_end`, `suff_start`, and `suff_end`.
#'
#' @examples
#' row_col_notation_list()
#' arrow_notation_list()
#' paren_notation_list()
#' 
#' @name row-col-notation
NULL


#' @export
#' @rdname row-col-notation
row_col_notation_list <- function(sep = " -> ",
                                  pref_start = NULL, pref_end = sep, 
                                  suff_start = sep, suff_end = NULL) {
  list(pref_start = pref_start, 
       pref_end = pref_end,
       suff_start = suff_start, 
       suff_end = suff_end)
}


#' @export
#' @rdname row-col-notation
arrow_notation_list <- function() {
  row_col_notation_list()
}


#' @export
#' @rdname row-col-notation
paren_notation_list <- function(suff_start = " [", suff_end = "]") {
  row_col_notation_list(sep = NULL,
                        pref_start = NULL, 
                        pref_end = suff_start,
                        suff_start = suff_start, 
                        suff_end = suff_end)
}


#' @export
#' @rdname row-col-notation
split_pref_suff <- function(x, notation_list = arrow_notation_list()) {
  # Strip off first pref_start
  no_pref_start <- gsub(pattern = paste0("^", Hmisc::escapeRegex(notation_list$pref_start)), replacement = "", x = x)
  # Strip off everything from first pref_end to end of string
  pref <- gsub(pattern = paste0(Hmisc::escapeRegex(notation_list$pref_end), ".*$"), replacement = "", x = no_pref_start)
  
  # Strip off last suff_end
  no_suff_end <- gsub(pattern = paste0(Hmisc::escapeRegex(notation_list$suff_end), "$"), replacement = "", x = x)
  # Strip off everything from start of the string to first suff_start
  ss <- notation_list$suff_start
  if (!is.null(notation_list$pref_start) & !is.null(notation_list$suff_start)) {
    if (notation_list$pref_start == notation_list$suff_start) {
      ss <- paste0(notation_list$pref_end, notation_list$suff_start)
    }
  }
  # Split at the first instance of suff_start to get two pieces
  suff <- stringi::stri_split_fixed(str = no_suff_end, fixed = TRUE, pattern = ss, n = 2)
  suff <- lapply(suff, function(s) {
    if (length(s) == 2) {
      # If we got two pieces, choose the second piece.
      s = s[[2]]
    }
  })
  if (length(x) == 1) {
    suff <- unlist(suff)
  }

  # Decide what the outgoing structure is
  if (length(x) > 1) {
    return(purrr::transpose(list(pref = pref, suff = suff)))
  } 
  list(pref = pref, suff = suff)
}


#' @export
#' @rdname row-col-notation
join_pref_suff <- function(ps, notation_list = arrow_notation_list()) {
  join_func <- function(ps) {
    out <- paste0(notation_list$pref_start, ps$pref, notation_list$pref_end)
    if (notation_list$pref_end != notation_list$suff_start) {
      out <- paste0(out, notation_list$suff_start)
    }
    paste0(out, ps$suff, notation_list$suff_end)
  }
  if (length(ps) == 2 & all(names(ps) == c("pref", "suff"))) {
    # We have a single list
    return(join_func(ps))
  }
  lapply(ps, join_func)
}


#' @export
#' @rdname row-col-notation
switch_pref_suff <- function(x, notation_list = arrow_notation_list()) {
  # Split prefixes and suffixes
  pref_suff <- split_pref_suff(x, notation_list = notation_list)
  
  flip_ps_func <- function(ps) {
    # pf is a list with only 2 items, pref and suff.
    out <- paste0(notation_list$pref_start, ps$suff, notation_list$pref_end)
    if (notation_list$pref_end != notation_list$suff_start) {
      out <- paste0(out, notation_list$suff_start)
    }
    paste0(out, ps$pref, notation_list$suff_end)
  }
  
  if (length(x) > 1) {
    # pref_suff is a list. So lapply to build a flipped list
    return(lapply(pref_suff, FUN = flip_ps_func))
  } 
  flip_ps_func(pref_suff)
}


#' @export
#' @rdname row-col-notation
switch_row_col_notation <- function(x, from, to, reverse = FALSE) {
  pref_suff <- split_pref_suff(x, notation_list = from)
  
  if (length(x) > 1) {
    
  }
}



#' #' @export
#' #' @rdname row-col-notation
#' switch_notation <- function(x, old_start, old_end, new_start, new_end) {
#'   if (!is.list(x)) {
#'     return(switch_notation_notlist(x, old_start = old_start, old_end = old_end, new_start = new_start, new_end = new_end))
#'   }
#'   
#'   # If we get here, we have a list.
#'   # We need to preserve the character of the list.
#'   lapply(x, function(s) {
#'     switch_notation_notlist(s, old_start = old_start, old_end = old_end, new_start = new_start, new_end = new_end)
#'   })
#' }
#' 
#' 
#' switch_notation_notlist <- function(x, old_notation_list, new_notation_list) {
#'   # x does is not a list. So we will proceed as though it is a character or can be coerced to a character.
#'   # Eliminate old_end from RHS of x
#'   no_end <- sub(pattern = paste0(old_end, "$"), replacement = "", x = x)
#'   # Split at the first instance of old_start to get two pieces
#'   old_split <- stringi::stri_split_fixed(str = no_end, fixed = TRUE, pattern = old_start, n = 2)
#'   # Rebuild string with RHS new_start LHS new_end
#'   out <- sapply(old_split, function(x) {
#'     # Check the number of pieces. Form a readable error message.
#'     assertthat::assert_that(length(x) <= 2, msg = paste0("switch_notation resulted in three pieces: ", utils::capture.output(cat(x, sep = ", "))))
#'     if (length(x) == 1) {
#'       # There was nothing to switch.
#'       # Simply return the existing string
#'       return(x)
#'     }
#'     old_prefix <- x[[1]]
#'     old_suffix <- x[[2]]
#'     paste0(old_suffix, new_start, old_prefix, new_end)
#'   })
#'   return(out)
#' }
#' 
#' 
#' #' @export
#' #' @rdname switch-notation
#' arrow_to_paren <- function(x,
#'                            old_start = IEATools::specify_notation$arrow, old_end = "",
#'                            new_start = IEATools::specify_notation$open, new_end = IEATools::specify_notation$close) {
#'   switch_notation(x,
#'                   old_start = old_start, old_end = old_end,
#'                   new_start = new_start, new_end = new_end)
#' }
#' 
#' 
#' #' @export
#' #' @rdname switch-notation
#' paren_to_arrow <- function(x,
#'                            old_start = IEATools::specify_notation$open, old_end = IEATools::specify_notation$close,
#'                            new_start = IEATools::specify_notation$arrow, new_end = "") {
#'   switch_notation(x,
#'                   old_start = old_start, old_end = old_end,
#'                   new_start = new_start, new_end = new_end)
#' }
#' 
#' 
#' #' @export
#' #' @rdname switch-notation
#' arrow_to_paren_byname <- function(m, margin = c(1, 2),
#'                                   old_start = IEATools::specify_notation$arrow, old_end = "",
#'                                   new_start = IEATools::specify_notation$open, new_end = IEATools::specify_notation$close) {
#'   switch_notation_byname(m, margin, worker_func = arrow_to_paren,
#'                          old_start = old_start, old_end = old_end, new_start = new_start, new_end = new_end)
#' }
#' 
#' 
#' #' @export
#' #' @rdname switch-notation
#' paren_to_arrow_byname <- function(m, margin = c(1, 2),
#'                                   old_start = IEATools::specify_notation$open, old_end = IEATools::specify_notation$close,
#'                                   new_start = IEATools::specify_notation$arrow, new_end = "") {
#'   switch_notation_byname(m, margin, worker_func = paren_to_arrow,
#'                          old_start = old_start, old_end = old_end, new_start = new_start, new_end = new_end)
#' }
#' 
#' 
#' #' @export
#' #' @rdname switch-notation
#' switch_notation_byname <- function(m, margin, worker_func,
#'                                    old_start, old_end, new_start, new_end) {
#'   assertthat::assert_that(all(margin %in% c(1, 2)), msg = "margin must be 1, 2, or both.")
#'   
#'   out <- m
#'   if (2 %in% margin) {
#'     # Transpose the matrices
#'     transposed <- matsbyname::transpose_byname(out)
#'     # re-call with margin = 1 to change from arrow to paren notation on the rows (which are really columns)
#'     switched <- switch_notation_byname(transposed, margin = 1, worker_func = worker_func,
#'                                        old_start = old_start, old_end = old_end, new_start = new_start, new_end = new_end)
#'     # Transpose
#'     out <- matsbyname::transpose_byname(switched)
#'   }
#'   if (1 %in% margin) {
#'     # Get the row names
#'     old_rownames <- matsbyname::getrownames_byname(out)
#'     # call func all all row names to create new row names
#'     new_rownames <- worker_func(old_rownames, old_start = old_start, old_end = old_end, new_start = new_start, new_end = new_end)
#'     # Set row names to the new row names
#'     out <- matsbyname::setrownames_byname(out, new_rownames)
#'   }
#'   # Return the result
#'   return(out)
# }