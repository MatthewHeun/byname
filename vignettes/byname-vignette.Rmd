---
title: "<tt>byname</tt> Vignette"
author: "Matthew Kuperus Heun"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{byname Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(magrittr)
library(dplyr)
library(byname)
```


## Introduction: The need for <tt>byname</tt>

Built-in functions to perform matrix operations in <tt>R</tt>
(and other languages) do not respect <tt>dimnames</tt>.

```{r}
productnames <- c("p1", "p2")
industrynames <- c("i1", "i2")
U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames))
U
Y <- matrix(1:4, ncol = 2, dimnames = list(rev(productnames), rev(industrynames)))
Y
# Non-sensical.  Row and column names not respected.
U + Y 
```

Analysts performing matrix operations must maintain strict order of 
rows and columns across all calculations.

```{r}
# Make a new version of Y (Y2), this time with dimnames in same order as U
Y2 <- matrix(4:1, ncol = 2, dimnames = list(productnames, industrynames))
Y2
# Now the sum is sensible. Neither row nor column names are respected.
U + Y2
```

The required bookkeeping can be both cumbersome and problematic.

The bookkeeping becomes cumbersome when analyses span many years (for example),
requiring the analyst to know *a-priori* 
the set of all rows and columns present in **all** years. 

```{r}
Y3 <- matrix(5:8, ncol = 2, dimnames = list(c("p1", "p3"), c("i1", "i3")))
Y3
# Non-sensical. Neither row nor column names are respected. Both "p3" and "i3" are missing from sum.
U + Y3
# Rather, need to insert missing rows in both U and Y before summing.
U_2000 <- matrix(c(1, 3, 0,
                   2, 4, 0,
                   0, 0, 0),
                 ncol = 3, byrow = TRUE, 
                 dimnames = list(c("p1", "p2", "p3"), c("i1", "i2", "i3")))
Y_2000 <- matrix(c(5, 0, 7,
                   0, 0, 0, 
                   6, 0, 8),
                 ncol = 3, byrow = TRUE,
                 dimnames = list(c("p1", "p2", "p3"), c("i1", "i2", "i3")))
U_2000
Y_2000
U_2000 + Y_2000
```

The bookkeeping becomes problematic when matrix inversion is required after 
rows or columns of zeroes are added.

```{r}
solve(U)
tryCatch(solve(U_2000), error = function(err){print(err)})
```

For ease of programming,
matrix operations should be performed <tt>byname</tt>
such that missing rows or columns are inserted automatically
or zero rows or columns can be removed as needed
prior to performing matrix algebra operations. 


## <tt>byname</tt> is the answer

The <tt>byname</tt> package provids an implementation of 
matrix mathematics that respects dimnames and allows
removal of zero-filled rows or columns as needed.
The challenges shown above can be solved without intervention
as shown below.

```{r}
# Same as U + Y2, without needing to create Y2.
sum_byname(U, Y)
# Same as U_2000 + Y_2000, without needing to modify U and Y3.
sum_byname(U, Y3)
# Eliminate Same result as solve(U)
U_2000 %>% clean_byname(margin = c(1,2), clean_value = 0) %>% solve
```

The <tt>byname</tt> package contains matrix algebra functions 
that respect the names of rows and columns. 
Commonly-used functions are:

* <tt>sum_byname</tt>
* <tt>difference_byname</tt>
* <tt>elementproduct_byname</tt>
* <tt>matrixproduct_byname</tt>
* <tt>elementquotient_byname</tt>
* <tt>rowsums_byname</tt>
* <tt>colsums_byname</tt>


## Other features

### Row and column names and types

In the preceding examples, row and column names were provided by the 
<tt>dimnames</tt> argument to the <tt>matrix</tt> function. 
However, <tt>byname</tt> provides the
<tt>setcolnames_byname</tt> and <tt>setrownames_byname</tt>
functions to perform the same tasks.

In addition, 
<tt>byname</tt> provides the option to specify a type for matrix rows and columns.
Row and column types are stored as attributes on the matrix object.
When combined with the <tt>byname</tt> functions, 
row and column types ensure with the correctness of matrix operations.
As an example, consider matrices **A**, **B**, and **C**:

```{r}
A <- matrix(c(1:4), nrow = 2, ncol = 2) %>% 
  setrownames_byname(productnames) %>% setcolnames_byname(industrynames) %>% 
  setrowtype("Products") %>% setcoltype("Industries")
A
B <- matrix(c(8:5), nrow = 2, ncol = 2) %>% 
  setrownames_byname(productnames) %>% setcolnames_byname(industrynames) %>% 
  setrowtype("Products") %>% setcoltype("Industries")
B

```



### <tt>byname</tt> functions also work with lists



### Works well with <tt>matsindf</tt>



## Putting it all together












