---
title: "<tt>byname</tt> Vignette"
author: "Matthew Kuperus Heun"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{byname Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(magrittr)
library(dplyr)
library(tidyr)
library(byname)
library(matsindf)
```


## Introduction: The need for <tt>byname</tt>

Built-in functions to perform matrix operations in <tt>R</tt>
(and other languages) do not respect the names of rows and columns
(<tt>dimnames</tt> in <tt>R</tt>).

```{r}
productnames <- c("p1", "p2")
industrynames <- c("i1", "i2")
U <- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames))
U
Y <- matrix(1:4, ncol = 2, dimnames = list(rev(productnames), rev(industrynames)))
Y
# Non-sensical.  Row and column names not respected.
U + Y 
```

As a result, 
analysts performing matrix operations must maintain strict order of 
rows and columns across all calculations.

```{r}
# Make a new version of Y (Y2), this time with dimnames in same order as U
Y2 <- matrix(4:1, ncol = 2, dimnames = list(productnames, industrynames))
Y2
# Now the sum is sensible. Neither row nor column names are respected.
U + Y2
```

The required bookkeeping can be both cumbersome and problematic.

The bookkeeping becomes cumbersome when analyses span many years (for example),
requiring the analyst to know *a-priori* 
the set of all rows and columns present in **all** years. 

```{r}
Y3 <- matrix(5:8, ncol = 2, dimnames = list(c("p1", "p3"), c("i1", "i3")))
Y3
# Non-sensical. Neither row nor column names are respected. Both "p3" and "i3" are missing from sum.
U + Y3
# Rather, need to insert missing rows in both U and Y before summing.
U_2000 <- matrix(c(1, 3, 0,
                   2, 4, 0,
                   0, 0, 0),
                 ncol = 3, byrow = TRUE, 
                 dimnames = list(c("p1", "p2", "p3"), c("i1", "i2", "i3")))
Y_2000 <- matrix(c(5, 0, 7,
                   0, 0, 0, 
                   6, 0, 8),
                 ncol = 3, byrow = TRUE,
                 dimnames = list(c("p1", "p2", "p3"), c("i1", "i2", "i3")))
U_2000
Y_2000
U_2000 + Y_2000
```

The bookkeeping becomes problematic when matrix inversion is required after 
rows or columns of zeroes are added.

```{r}
solve(U)
tryCatch(solve(U_2000), error = function(err){print(err)})
```

For ease of programming,
matrix operations should be performed *byname*,
without analyst intervention,
such that missing rows or columns are inserted automatically
or zero rows or columns can be removed as needed
prior to performing matrix algebra operations. 


## <tt>byname</tt> is the answer

The <tt>byname</tt> package implements
matrix mathematics in a way that 
respects row and column names and 
allows removal of zero-filled rows or columns as needed.
The challenges shown above can be solved without intervention
with the <tt>byname</tt> package.

```{r}
# Same as U + Y2, without needing to create Y2.
sum_byname(U, Y)
# Same as U_2000 + Y_2000, but U and Y3 are unmodified.
sum_byname(U, Y3)
# Eliminate zero-filled rows and columns. Same result as solve(U).
U_2000 %>% clean_byname(margin = c(1,2), clean_value = 0) %>% solve()
```

In addition to <tt>sum_byname</tt>,
the <tt>byname</tt> package contains matrix algebra functions 
that respect the names of rows and columns. 
Commonly-used functions are:

* <tt>sum_byname</tt>
* <tt>difference_byname</tt>
* <tt>elementproduct_byname</tt>
* <tt>matrixproduct_byname</tt>
* <tt>elementquotient_byname</tt>
* <tt>rowsums_byname</tt>
* <tt>colsums_byname</tt>
* <tt>invert_byname</tt>
* <tt>transpose_byname</tt>


## Additional features

The <tt>byname</tt> package has several additional features.


### Row and column names and types

In the preceding examples, row and column names were provided by the 
<tt>dimnames</tt> argument to the <tt>matrix</tt> function. 
However, <tt>byname</tt> provides the
<tt>setcolnames_byname</tt> and <tt>setrownames_byname</tt>
functions to perform the same tasks.

In addition, 
<tt>byname</tt> provides the option to specify a data type for matrix rows and columns.
The data types are character strings stored
as attributes of the matrix object.
The <tt>byname</tt> functions ensure correctness
of row and column types, 
throwing errors when appropriate.
As an example, consider matrices **A**, **B**, and **C**:

```{r}
A <- matrix(1:4, nrow = 2, ncol = 2) %>% 
  setrownames_byname(productnames) %>% setcolnames_byname(industrynames) %>% 
  setrowtype("Products") %>% setcoltype("Industries")
A
B <- matrix(8:5, nrow = 2, ncol = 2) %>% 
  setrownames_byname(productnames) %>% setcolnames_byname(industrynames) %>% 
  setrowtype("Products") %>% setcoltype("Industries")
B
C <- matrix(1:4, nrow = 2, ncol = 2) %>% 
  setcolnames_byname(productnames) %>% setrownames_byname(industrynames) %>% 
  setrowtype("Industries") %>% setcoltype("Products")
C
```

**B** can be added to **A**, because
row and column types are identical.

```{r}
sum_byname(A, B)
```
However, **C** cannot be added to **A** (or **B**),
because row and column types disagree.

```{r}
tryCatch(sum_byname(A, C), error = function(err){print(err)})
```

In this case, a sum is possible if 
**C** is transposed prior to adding to **A**,
because row and column types of **A** and **C**^T^ are identical.

```{r}
sum_byname(A, transpose_byname(C))
```

Matrices **A** and **B** can be element-multiplied and element-divided
for the same reason they can be summed: 
row and column types agree.

```{r}
elementproduct_byname(A, B)
elementquotient_byname(A, B)
```

Note that **A** and **C** can be matrix-multiplied,
because the column type of **A** and the row type of **C** 
are identical (<tt>Industries</tt>).
The result is a <tt>Products</tt>-by-<tt>Products</tt>
matrix.

```{r}
matrixproduct_byname(A, C)
```

However, **A** and **B** cannot be matrix-multiplied,
because the column type and **A** and the row type of **B** are different,
<tt>Industries</tt> and <tt>Products</tt>, respectively.

```{r}
tryCatch(matrixproduct_byname(A, B), error = function(err){print(err)})
```


### <tt>byname</tt> functions also work with lists

The functions in the <tt>byname</tt> package 
work equally well when lists of matrices are arguments,
returning lists as appropriate.

```{r}
sum_byname(A, list(B, B))
elementproduct_byname(list(A, A), B)
matrixproduct_byname(list(A, A), list(C, C))
```


### <tt>byname</tt> works well with <tt>matsindf</tt>

The <tt>matsindf</tt> package provides functions that convert
tidy data frames of matrix elements into data frames of matrices.
(For details, see the <tt>matsindf</tt> vignette.)
The following example demonstrates an approach to creating a data frame of matrices.

```{r}
tidy <- data.frame(
  matrix = c("A", "A", "A", "A", "B", "B", "B", "B"),
  row = c("p1", "p1", "p2", "p2", "p1", "p1", "p2", "p2"),
  col = c("i1", "i2", "i1", "i2", "i1", "i2", "i1", "i2"),
  vals = c(1, 3, 2, 4, 8, 6, 7, 5)
) %>% 
  mutate(
    rowtype = "Industries",
    coltype  = "Products"
  ) %>% 
  group_by(matrix)
tidy
mats <- tidy %>% 
  collapse_to_matrices(matnames = "matrix", values = "vals", 
                       rownames = "row", colnames = "col", 
                       rowtypes = "rowtype", coltypes = "coltype") %>% 
  rename(
    matrix.name = matrix,
    matrix = vals
  )
mats
mats$matrix[[1]]
mats$matrix[[2]]
```


## Putting it all together

Data frames of matrices are like spreadsheets 
with magic cells 
that can contain entire matrices.
Because data frame columns are lists and
because <tt>byname</tt> works well with lists,
<tt>byname</tt> functions can be used with 
<tt>tidyr</tt> and <tt>dplyr</tt> functions such as
<tt>spread</tt> and <tt>mutate</tt>.

```{r}
result <- mats %>% 
  spread(key = matrix.name, value = matrix) %>% 
  rbind(., .) %>% 
  mutate(
    c = 1:2,
    # Sums all rows of mats with a single instruction.
    sum = sum_byname(A, B),
    product = elementproduct_byname(c, sum)
  )
result
result$sum[[1]]
result$sum[[2]]
result$product[[1]]
result$product[[2]]
```


## Summary

The <tt>byname</tt> package simplifies analyses 
in which row and column names ought to be respected.
It provides optional row and column types, thereby
ensuring that only valid matrix operations are performed.
Finally, <tt>byname</tt> functions work equally well with lists
to allow use with <tt>tidyr</tt> and <tt>dplyr</tt> 
approaches to manipulating data.






